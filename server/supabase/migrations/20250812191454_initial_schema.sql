create sequence "public"."board_1_post_id_seq";


  create table "public"."action_logs" (
    "id" bigint generated by default as identity not null,
    "user_id" uuid,
    "ip_address" inet,
    "action_type" text not null,
    "created_at" timestamp with time zone not null default now()
      );


alter table "public"."action_logs" enable row level security;


  create table "public"."app_config" (
    "key" text not null,
    "value" text not null
      );



  create table "public"."boards" (
    "id" bigint generated by default as identity not null,
    "slug" text not null,
    "name" text not null,
    "description" text,
    "created_at" timestamp with time zone default now()
      );



  create table "public"."post_mentions" (
    "source_post_id" bigint not null,
    "target_post_id" bigint not null
      );



  create table "public"."posts" (
    "id" bigint generated by default as identity not null,
    "board_id" bigint not null,
    "thread_id" bigint,
    "user_id" uuid,
    "image_path" text,
    "comment" text,
    "poster_ip" inet,
    "created_at" timestamp with time zone default now(),
    "board_post_id" integer
      );



  create table "public"."profiles" (
    "id" uuid not null,
    "username" text,
    "avatar_url" text,
    "role" text not null default 'USER'::text,
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."profiles" enable row level security;

CREATE UNIQUE INDEX action_logs_pkey ON public.action_logs USING btree (id);

CREATE UNIQUE INDEX app_config_pkey ON public.app_config USING btree (key);

CREATE UNIQUE INDEX boards_pkey ON public.boards USING btree (id);

CREATE UNIQUE INDEX boards_slug_key ON public.boards USING btree (slug);

CREATE INDEX idx_action_logs_ip_address_action_type ON public.action_logs USING btree (ip_address, action_type);

CREATE INDEX idx_action_logs_user_id_action_type ON public.action_logs USING btree (user_id, action_type);

CREATE INDEX idx_post_mentions_target_post_id ON public.post_mentions USING btree (target_post_id);

CREATE INDEX idx_posts_thread_id ON public.posts USING btree (thread_id);

CREATE UNIQUE INDEX post_mentions_pkey ON public.post_mentions USING btree (source_post_id, target_post_id);

CREATE UNIQUE INDEX posts_board_id_board_post_id_key ON public.posts USING btree (board_id, board_post_id);

CREATE UNIQUE INDEX posts_pkey ON public.posts USING btree (id);

CREATE UNIQUE INDEX posts_unique_non_null_image_path ON public.posts USING btree (image_path) WHERE (image_path IS NOT NULL);

CREATE UNIQUE INDEX profiles_pkey ON public.profiles USING btree (id);

CREATE UNIQUE INDEX profiles_username_key ON public.profiles USING btree (username);

alter table "public"."action_logs" add constraint "action_logs_pkey" PRIMARY KEY using index "action_logs_pkey";

alter table "public"."app_config" add constraint "app_config_pkey" PRIMARY KEY using index "app_config_pkey";

alter table "public"."boards" add constraint "boards_pkey" PRIMARY KEY using index "boards_pkey";

alter table "public"."post_mentions" add constraint "post_mentions_pkey" PRIMARY KEY using index "post_mentions_pkey";

alter table "public"."posts" add constraint "posts_pkey" PRIMARY KEY using index "posts_pkey";

alter table "public"."profiles" add constraint "profiles_pkey" PRIMARY KEY using index "profiles_pkey";

alter table "public"."action_logs" add constraint "action_logs_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."action_logs" validate constraint "action_logs_user_id_fkey";

alter table "public"."boards" add constraint "boards_slug_key" UNIQUE using index "boards_slug_key";

alter table "public"."post_mentions" add constraint "post_mentions_source_post_id_fkey" FOREIGN KEY (source_post_id) REFERENCES posts(id) ON DELETE CASCADE not valid;

alter table "public"."post_mentions" validate constraint "post_mentions_source_post_id_fkey";

alter table "public"."post_mentions" add constraint "post_mentions_target_post_id_fkey" FOREIGN KEY (target_post_id) REFERENCES posts(id) ON DELETE CASCADE not valid;

alter table "public"."post_mentions" validate constraint "post_mentions_target_post_id_fkey";

alter table "public"."posts" add constraint "posts_board_id_board_post_id_key" UNIQUE using index "posts_board_id_board_post_id_key";

alter table "public"."posts" add constraint "posts_board_id_fkey" FOREIGN KEY (board_id) REFERENCES boards(id) ON DELETE CASCADE not valid;

alter table "public"."posts" validate constraint "posts_board_id_fkey";

alter table "public"."posts" add constraint "posts_thread_id_fkey" FOREIGN KEY (thread_id) REFERENCES posts(id) ON DELETE CASCADE not valid;

alter table "public"."posts" validate constraint "posts_thread_id_fkey";

alter table "public"."posts" add constraint "posts_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE SET NULL not valid;

alter table "public"."posts" validate constraint "posts_user_id_fkey";

alter table "public"."profiles" add constraint "profiles_id_fkey" FOREIGN KEY (id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."profiles" validate constraint "profiles_id_fkey";

alter table "public"."profiles" add constraint "profiles_username_key" UNIQUE using index "profiles_username_key";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.create_board_post_sequence()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO ''
AS $function$
DECLARE
  seq_name_qualified TEXT;
BEGIN
  -- Construct the fully qualified sequence name to ensure it's created in 'public'.
  seq_name_qualified := 'public.board_' || NEW.id || '_post_id_seq';

  -- Create the sequence.
  EXECUTE format('CREATE SEQUENCE %s;', seq_name_qualified);

  -- Grant USAGE permission to the admin role used by the API.
  EXECUTE format('GRANT USAGE ON SEQUENCE %s TO supabase_admin;', seq_name_qualified);
  
  -- Notify PostgREST to reload its schema cache, solving the caching issue.
  PERFORM pg_notify('pgrst', 'reload schema');
  
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.create_post(p_board_slug text DEFAULT NULL::text, p_comment text DEFAULT NULL::text, p_user_id uuid DEFAULT NULL::uuid, p_poster_ip inet DEFAULT NULL::inet, p_thread_id bigint DEFAULT NULL::bigint, p_image_path text DEFAULT NULL::text)
 RETURNS TABLE(j json)
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO ''
AS $function$
DECLARE
  target_board_id BIGINT;
  new_post_id BIGINT;
  new_board_post_id INT;
  seq_name TEXT;
  mention_id BIGINT;
BEGIN
  -- 1. Determine the board_id.
  IF p_thread_id IS NOT NULL THEN
    -- This is a reply; get the board_id from the parent thread.
    SELECT board_id INTO target_board_id FROM public.posts WHERE id = p_thread_id;
    IF NOT FOUND THEN RAISE EXCEPTION 'Parent thread with id % not found', p_thread_id; END IF;
  ELSE
    -- This is a new thread (OP); look up the board_id from the slug.
    IF p_board_slug IS NULL THEN RAISE EXCEPTION 'boardSlug is required for new threads.'; END IF;
    SELECT id INTO target_board_id FROM public.boards WHERE slug = p_board_slug;
    IF NOT FOUND THEN RAISE EXCEPTION 'Board with slug % not found', p_board_slug; END IF;
    -- An OP must have an image.
    IF p_image_path IS NULL THEN RAISE EXCEPTION 'An image is required to start a new thread.'; END IF;
  END IF;

  -- 2. Get the next post number from the correct board's sequence.
  seq_name := 'public.board_' || target_board_id || '_post_id_seq';
  new_board_post_id := pg_catalog.nextval(seq_name);

  -- 3. Insert the new post record.
  INSERT INTO public.posts (board_id, thread_id, image_path, comment, user_id, poster_ip, board_post_id)
  VALUES (target_board_id, p_thread_id, p_image_path, p_comment, p_user_id, p_poster_ip, new_board_post_id)
  RETURNING id INTO new_post_id;

  -- 4. If it's a new thread (OP), set its thread_id to its own id.
  IF p_thread_id IS NULL THEN
    UPDATE public.posts SET thread_id = new_post_id WHERE id = new_post_id;
  END IF;
  
  -- 5. Parse comment for mentions and insert into post_mentions.
  -- Only run if there's a comment to parse.
  IF p_comment IS NOT NULL THEN
    FOR mention_id IN
      SELECT (pg_catalog.regexp_matches(p_comment, '>>(\d+)', 'g'))[1]::bigint
    LOOP
      INSERT INTO public.post_mentions (source_post_id, target_post_id)
      VALUES (new_post_id, mention_id)
      ON CONFLICT (source_post_id, target_post_id) DO NOTHING;
    END LOOP;
  END IF;

  -- 6. Return the full post data as a JSON object.
  RETURN QUERY
    SELECT pg_catalog.to_json(p) FROM public.posts p WHERE p.id = new_post_id;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.delete_post_storage_object()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO ''
AS $function$
BEGIN
  -- Check if the post being deleted actually has an image.
  IF OLD.image_path IS NOT NULL THEN
    -- Delete the object from the 'posts' bucket in Supabase Storage.
    PERFORM storage.delete_object('posts', OLD.image_path);
  END IF;
  RETURN OLD;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_thread_by_id(p_post_id bigint, p_replies_limit integer, p_replies_offset integer)
 RETURNS json
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO ''
AS $function$
DECLARE
  thread_data JSON;
BEGIN
  -- This complex query builds a nested JSON object in a single database round-trip.
  SELECT
    -- Use json_build_object to construct the final JSON structure.
    pg_catalog.json_build_object(
      'op', (SELECT pg_catalog.to_json(op) FROM (SELECT * FROM public.posts WHERE id = p_post_id) op),
      'replies', (
        SELECT COALESCE(pg_catalog.json_agg(r), '[]'::json)
        FROM (
          SELECT
            p.*,
            -- For each reply, create a JSON array of posts that replied TO IT.
            (
              SELECT COALESCE(pg_catalog.json_agg(m.source_post_id), '[]'::json)
              FROM public.post_mentions m
              WHERE m.target_post_id = p.id
            ) as backlinks
          FROM
            public.posts p
          WHERE
            p.thread_id = p_post_id AND p.id != p_post_id -- Find replies in this thread
          ORDER BY
            p.created_at ASC
          LIMIT p_replies_limit
          OFFSET p_replies_offset
        ) r
      ),
      'totalReplyCount', (SELECT count(*) FROM public.posts WHERE thread_id = p_post_id AND id != p_post_id)
    )
  INTO thread_data;

  RETURN thread_data;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_threads_by_board_slug(p_board_slug text, p_page_limit integer, p_page_offset integer)
 RETURNS json
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO ''
AS $function$
DECLARE
  target_board_id BIGINT;
  total_thread_count INT;
  threads_json JSON;
BEGIN
  -- 1. Find the board's ID from its slug.
  SELECT id INTO target_board_id FROM public.boards WHERE slug = p_board_slug;
  IF NOT FOUND THEN
    RAISE EXCEPTION 'Board with slug % not found', p_board_slug;
  END IF;

  -- 2. Get the paginated list of threads and their reply counts.
  SELECT json_agg(t) INTO threads_json FROM (
    SELECT
      p.*,
      -- Subquery to count all replies for this thread.
      (SELECT count(*) FROM public.posts r WHERE r.thread_id = p.id AND r.id != p.id) as reply_count,
      -- Subquery to count only replies that have an image.
      (SELECT count(*) FROM public.posts r WHERE r.thread_id = p.id AND r.id != p.id AND r.image_path IS NOT NULL) as image_reply_count
    FROM
      public.posts p
    WHERE
      p.board_id = target_board_id AND p.thread_id = p.id -- This condition finds OPs only
    ORDER BY
      p.created_at DESC -- Change this later for "bump order"
    LIMIT p_page_limit
    OFFSET p_page_offset
  ) t;
  
  -- 3. Get the total count of all threads on this board for pagination.
  SELECT count(*) INTO total_thread_count
  FROM public.posts p
  WHERE p.board_id = target_board_id AND p.thread_id = p.id;

  -- 4. Combine the results into a single JSON object.
  RETURN json_build_object(
    'threads', COALESCE(threads_json, '[]'::json),
    'totalCount', total_thread_count
  );
END;
$function$
;

grant delete on table "public"."action_logs" to "anon";

grant insert on table "public"."action_logs" to "anon";

grant references on table "public"."action_logs" to "anon";

grant select on table "public"."action_logs" to "anon";

grant trigger on table "public"."action_logs" to "anon";

grant truncate on table "public"."action_logs" to "anon";

grant update on table "public"."action_logs" to "anon";

grant delete on table "public"."action_logs" to "authenticated";

grant insert on table "public"."action_logs" to "authenticated";

grant references on table "public"."action_logs" to "authenticated";

grant select on table "public"."action_logs" to "authenticated";

grant trigger on table "public"."action_logs" to "authenticated";

grant truncate on table "public"."action_logs" to "authenticated";

grant update on table "public"."action_logs" to "authenticated";

grant delete on table "public"."action_logs" to "service_role";

grant insert on table "public"."action_logs" to "service_role";

grant references on table "public"."action_logs" to "service_role";

grant select on table "public"."action_logs" to "service_role";

grant trigger on table "public"."action_logs" to "service_role";

grant truncate on table "public"."action_logs" to "service_role";

grant update on table "public"."action_logs" to "service_role";

grant delete on table "public"."app_config" to "anon";

grant insert on table "public"."app_config" to "anon";

grant references on table "public"."app_config" to "anon";

grant select on table "public"."app_config" to "anon";

grant trigger on table "public"."app_config" to "anon";

grant truncate on table "public"."app_config" to "anon";

grant update on table "public"."app_config" to "anon";

grant delete on table "public"."app_config" to "authenticated";

grant insert on table "public"."app_config" to "authenticated";

grant references on table "public"."app_config" to "authenticated";

grant select on table "public"."app_config" to "authenticated";

grant trigger on table "public"."app_config" to "authenticated";

grant truncate on table "public"."app_config" to "authenticated";

grant update on table "public"."app_config" to "authenticated";

grant delete on table "public"."app_config" to "service_role";

grant insert on table "public"."app_config" to "service_role";

grant references on table "public"."app_config" to "service_role";

grant select on table "public"."app_config" to "service_role";

grant trigger on table "public"."app_config" to "service_role";

grant truncate on table "public"."app_config" to "service_role";

grant update on table "public"."app_config" to "service_role";

grant delete on table "public"."boards" to "anon";

grant insert on table "public"."boards" to "anon";

grant references on table "public"."boards" to "anon";

grant select on table "public"."boards" to "anon";

grant trigger on table "public"."boards" to "anon";

grant truncate on table "public"."boards" to "anon";

grant update on table "public"."boards" to "anon";

grant delete on table "public"."boards" to "authenticated";

grant insert on table "public"."boards" to "authenticated";

grant references on table "public"."boards" to "authenticated";

grant select on table "public"."boards" to "authenticated";

grant trigger on table "public"."boards" to "authenticated";

grant truncate on table "public"."boards" to "authenticated";

grant update on table "public"."boards" to "authenticated";

grant delete on table "public"."boards" to "service_role";

grant insert on table "public"."boards" to "service_role";

grant references on table "public"."boards" to "service_role";

grant select on table "public"."boards" to "service_role";

grant trigger on table "public"."boards" to "service_role";

grant truncate on table "public"."boards" to "service_role";

grant update on table "public"."boards" to "service_role";

grant delete on table "public"."post_mentions" to "anon";

grant insert on table "public"."post_mentions" to "anon";

grant references on table "public"."post_mentions" to "anon";

grant select on table "public"."post_mentions" to "anon";

grant trigger on table "public"."post_mentions" to "anon";

grant truncate on table "public"."post_mentions" to "anon";

grant update on table "public"."post_mentions" to "anon";

grant delete on table "public"."post_mentions" to "authenticated";

grant insert on table "public"."post_mentions" to "authenticated";

grant references on table "public"."post_mentions" to "authenticated";

grant select on table "public"."post_mentions" to "authenticated";

grant trigger on table "public"."post_mentions" to "authenticated";

grant truncate on table "public"."post_mentions" to "authenticated";

grant update on table "public"."post_mentions" to "authenticated";

grant delete on table "public"."post_mentions" to "service_role";

grant insert on table "public"."post_mentions" to "service_role";

grant references on table "public"."post_mentions" to "service_role";

grant select on table "public"."post_mentions" to "service_role";

grant trigger on table "public"."post_mentions" to "service_role";

grant truncate on table "public"."post_mentions" to "service_role";

grant update on table "public"."post_mentions" to "service_role";

grant delete on table "public"."posts" to "anon";

grant insert on table "public"."posts" to "anon";

grant references on table "public"."posts" to "anon";

grant select on table "public"."posts" to "anon";

grant trigger on table "public"."posts" to "anon";

grant truncate on table "public"."posts" to "anon";

grant update on table "public"."posts" to "anon";

grant delete on table "public"."posts" to "authenticated";

grant insert on table "public"."posts" to "authenticated";

grant references on table "public"."posts" to "authenticated";

grant select on table "public"."posts" to "authenticated";

grant trigger on table "public"."posts" to "authenticated";

grant truncate on table "public"."posts" to "authenticated";

grant update on table "public"."posts" to "authenticated";

grant delete on table "public"."posts" to "service_role";

grant insert on table "public"."posts" to "service_role";

grant references on table "public"."posts" to "service_role";

grant select on table "public"."posts" to "service_role";

grant trigger on table "public"."posts" to "service_role";

grant truncate on table "public"."posts" to "service_role";

grant update on table "public"."posts" to "service_role";

grant delete on table "public"."profiles" to "anon";

grant insert on table "public"."profiles" to "anon";

grant references on table "public"."profiles" to "anon";

grant select on table "public"."profiles" to "anon";

grant trigger on table "public"."profiles" to "anon";

grant truncate on table "public"."profiles" to "anon";

grant update on table "public"."profiles" to "anon";

grant delete on table "public"."profiles" to "authenticated";

grant insert on table "public"."profiles" to "authenticated";

grant references on table "public"."profiles" to "authenticated";

grant select on table "public"."profiles" to "authenticated";

grant trigger on table "public"."profiles" to "authenticated";

grant truncate on table "public"."profiles" to "authenticated";

grant update on table "public"."profiles" to "authenticated";

grant delete on table "public"."profiles" to "service_role";

grant insert on table "public"."profiles" to "service_role";

grant references on table "public"."profiles" to "service_role";

grant select on table "public"."profiles" to "service_role";

grant trigger on table "public"."profiles" to "service_role";

grant truncate on table "public"."profiles" to "service_role";

grant update on table "public"."profiles" to "service_role";


  create policy "Public profiles are viewable by everyone."
  on "public"."profiles"
  as permissive
  for select
  to public
using (true);


CREATE TRIGGER on_board_creation AFTER INSERT ON public.boards FOR EACH ROW EXECUTE FUNCTION create_board_post_sequence();

CREATE TRIGGER before_delete_post BEFORE DELETE ON public.posts FOR EACH ROW EXECUTE FUNCTION delete_post_storage_object();


